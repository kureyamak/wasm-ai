!function(e,t){if("object"==typeof exports&&"object"==typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{var r=t();for(var n in r)("object"==typeof exports?exports:e)[n]=r[n]}}(self,(()=>(()=>{"use strict";var e={986:(e,t,r)=>{r.d(t,{debug:()=>n});const n=new class{enable(e){this.log=function(e,t){return e?console.log.bind(console,"%c%s","color: #265BA0",t):()=>{}}(void 0===e||e,this.prefix)}get enabled(){return this.isEnabled}constructor(e){this.isEnabled=e,this.prefix="wasi:",this.enable(e)}}(!1)},228:(e,t,r)=>{r.d(t,{CLOCKID_MONOTONIC:()=>s,CLOCKID_REALTIME:()=>n,Ciovec:()=>a,ERRNO_BADF:()=>f,ERRNO_NOSYS:()=>i,ERRNO_SUCCESS:()=>o,Iovec:()=>d});const n=0,s=1,o=0,f=8,i=52;class d{static read_bytes(e,t){const r=new d;return r.buf=e.getUint32(t,!0),r.buf_len=e.getUint32(t+4,!0),r}static read_bytes_array(e,t,r){const n=[];for(let s=0;s<r;s++)n.push(d.read_bytes(e,t+8*s));return n}}class a{static read_bytes(e,t){const r=new a;return r.buf=e.getUint32(t,!0),r.buf_len=e.getUint32(t+4,!0),r}static read_bytes_array(e,t,r){const n=[];for(let s=0;s<r;s++)n.push(a.read_bytes(e,t+8*s));return n}}}},t={};function r(n){var s=t[n];if(void 0!==s)return s.exports;var o=t[n]={exports:{}};return e[n](o,o.exports,r),o.exports}r.d=(e,t)=>{for(var n in t)r.o(t,n)&&!r.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var n={};return(()=>{r.r(n),r.d(n,{WASIProcExit:()=>s,default:()=>o});var e=r(228),t=r(986);class s extends Error{constructor(e){super("exit with exit code "+e),this.code=e}}let o=class{start(e){this.inst=e;try{return e.exports._start(),0}catch(e){if(e instanceof s)return e.code;throw e}}initialize(e){this.inst=e,e.exports._initialize()}constructor(r,n,o,f={}){this.args=[],this.env=[],this.fds=[],t.debug.enable(f.debug),this.args=r,this.env=n,this.fds=o;const i=this;this.wasiImport={args_sizes_get(e,r){const n=new DataView(i.inst.exports.memory.buffer);n.setUint32(e,i.args.length,!0);let s=0;for(const e of i.args)s+=e.length+1;return n.setUint32(r,s,!0),t.debug.log(n.getUint32(e,!0),n.getUint32(r,!0)),0},args_get(e,r){const n=new DataView(i.inst.exports.memory.buffer),s=new Uint8Array(i.inst.exports.memory.buffer),o=r;for(let t=0;t<i.args.length;t++){n.setUint32(e,r,!0),e+=4;const o=(new TextEncoder).encode(i.args[t]);s.set(o,r),n.setUint8(r+o.length,0),r+=o.length+1}return t.debug.enabled&&t.debug.log(new TextDecoder("utf-8").decode(s.slice(o,r))),0},environ_sizes_get(e,r){const n=new DataView(i.inst.exports.memory.buffer);n.setUint32(e,i.env.length,!0);let s=0;for(const e of i.env)s+=e.length+1;return n.setUint32(r,s,!0),t.debug.log(n.getUint32(e,!0),n.getUint32(r,!0)),0},environ_get(e,r){const n=new DataView(i.inst.exports.memory.buffer),s=new Uint8Array(i.inst.exports.memory.buffer),o=r;for(let t=0;t<i.env.length;t++){n.setUint32(e,r,!0),e+=4;const o=(new TextEncoder).encode(i.env[t]);s.set(o,r),n.setUint8(r+o.length,0),r+=o.length+1}return t.debug.enabled&&t.debug.log(new TextDecoder("utf-8").decode(s.slice(o,r))),0},clock_res_get(t,r){let n;switch(t){case e.CLOCKID_MONOTONIC:n=5000n;break;case e.CLOCKID_REALTIME:n=1000000n;break;default:return e.ERRNO_NOSYS}return new DataView(i.inst.exports.memory.buffer).setBigUint64(r,n,!0),e.ERRNO_SUCCESS},clock_time_get(t,r,n){const s=new DataView(i.inst.exports.memory.buffer);if(t===e.CLOCKID_REALTIME)s.setBigUint64(n,1000000n*BigInt((new Date).getTime()),!0);else if(t==e.CLOCKID_MONOTONIC){let e;try{e=BigInt(Math.round(1e6*performance.now()))}catch(t){e=0n}s.setBigUint64(n,e,!0)}else s.setBigUint64(n,0n,!0);return 0},fd_advise:(t,r,n,s)=>null!=i.fds[t]?i.fds[t].fd_advise(r,n,s):e.ERRNO_BADF,fd_allocate:(t,r,n)=>null!=i.fds[t]?i.fds[t].fd_allocate(r,n):e.ERRNO_BADF,fd_close(t){if(null!=i.fds[t]){const e=i.fds[t].fd_close();return i.fds[t]=void 0,e}return e.ERRNO_BADF},fd_datasync:t=>null!=i.fds[t]?i.fds[t].fd_datasync():e.ERRNO_BADF,fd_fdstat_get(t,r){if(null!=i.fds[t]){const{ret:e,fdstat:n}=i.fds[t].fd_fdstat_get();return null!=n&&n.write_bytes(new DataView(i.inst.exports.memory.buffer),r),e}return e.ERRNO_BADF},fd_fdstat_set_flags:(t,r)=>null!=i.fds[t]?i.fds[t].fd_fdstat_set_flags(r):e.ERRNO_BADF,fd_fdstat_set_rights:(t,r,n)=>null!=i.fds[t]?i.fds[t].fd_fdstat_set_rights(r,n):e.ERRNO_BADF,fd_filestat_get(t,r){if(null!=i.fds[t]){const{ret:e,filestat:n}=i.fds[t].fd_filestat_get();return null!=n&&n.write_bytes(new DataView(i.inst.exports.memory.buffer),r),e}return e.ERRNO_BADF},fd_filestat_set_size:(t,r)=>null!=i.fds[t]?i.fds[t].fd_filestat_set_size(r):e.ERRNO_BADF,fd_filestat_set_times:(t,r,n,s)=>null!=i.fds[t]?i.fds[t].fd_filestat_set_times(r,n,s):e.ERRNO_BADF,fd_pread(t,r,n,s,o){const f=new DataView(i.inst.exports.memory.buffer),d=new Uint8Array(i.inst.exports.memory.buffer);if(null!=i.fds[t]){const a=e.Iovec.read_bytes_array(f,r,n),{ret:l,nread:u}=i.fds[t].fd_pread(d,a,s);return f.setUint32(o,u,!0),l}return e.ERRNO_BADF},fd_prestat_get(t,r){const n=new DataView(i.inst.exports.memory.buffer);if(null!=i.fds[t]){const{ret:e,prestat:s}=i.fds[t].fd_prestat_get();return null!=s&&s.write_bytes(n,r),e}return e.ERRNO_BADF},fd_prestat_dir_name(t,r,n){if(null!=i.fds[t]){const{ret:e,prestat_dir_name:n}=i.fds[t].fd_prestat_dir_name();return null!=n&&new Uint8Array(i.inst.exports.memory.buffer).set(n,r),e}return e.ERRNO_BADF},fd_pwrite(t,r,n,s,o){const f=new DataView(i.inst.exports.memory.buffer),d=new Uint8Array(i.inst.exports.memory.buffer);if(null!=i.fds[t]){const a=e.Ciovec.read_bytes_array(f,r,n),{ret:l,nwritten:u}=i.fds[t].fd_pwrite(d,a,s);return f.setUint32(o,u,!0),l}return e.ERRNO_BADF},fd_read(t,r,n,s){const o=new DataView(i.inst.exports.memory.buffer),f=new Uint8Array(i.inst.exports.memory.buffer);if(null!=i.fds[t]){const d=e.Iovec.read_bytes_array(o,r,n),{ret:a,nread:l}=i.fds[t].fd_read(f,d);return o.setUint32(s,l,!0),a}return e.ERRNO_BADF},fd_readdir(t,r,n,s,o){const f=new DataView(i.inst.exports.memory.buffer),d=new Uint8Array(i.inst.exports.memory.buffer);if(null!=i.fds[t]){let e=0;for(;;){const{ret:a,dirent:l}=i.fds[t].fd_readdir_single(s);if(0!=a)return f.setUint32(o,e,!0),a;if(null==l)break;if(n-e<l.head_length()){e=n;break}const u=new ArrayBuffer(l.head_length());if(l.write_head_bytes(new DataView(u),0),d.set(new Uint8Array(u).slice(0,Math.min(u.byteLength,n-e)),r),r+=l.head_length(),e+=l.head_length(),n-e<l.name_length()){e=n;break}l.write_name_bytes(d,r,n-e),r+=l.name_length(),e+=l.name_length(),s=l.d_next}return f.setUint32(o,e,!0),0}return e.ERRNO_BADF},fd_renumber(t,r){if(null!=i.fds[t]&&null!=i.fds[r]){const e=i.fds[r].fd_close();return 0!=e?e:(i.fds[r]=i.fds[t],i.fds[t]=void 0,0)}return e.ERRNO_BADF},fd_seek(t,r,n,s){const o=new DataView(i.inst.exports.memory.buffer);if(null!=i.fds[t]){const{ret:e,offset:f}=i.fds[t].fd_seek(r,n);return o.setBigInt64(s,f,!0),e}return e.ERRNO_BADF},fd_sync:t=>null!=i.fds[t]?i.fds[t].fd_sync():e.ERRNO_BADF,fd_tell(t,r){const n=new DataView(i.inst.exports.memory.buffer);if(null!=i.fds[t]){const{ret:e,offset:s}=i.fds[t].fd_tell();return n.setBigUint64(r,s,!0),e}return e.ERRNO_BADF},fd_write(t,r,n,s){const o=new DataView(i.inst.exports.memory.buffer),f=new Uint8Array(i.inst.exports.memory.buffer);if(null!=i.fds[t]){const d=e.Ciovec.read_bytes_array(o,r,n),{ret:a,nwritten:l}=i.fds[t].fd_write(f,d);return o.setUint32(s,l,!0),a}return e.ERRNO_BADF},path_create_directory(e,t,r){const n=new Uint8Array(i.inst.exports.memory.buffer);if(null!=i.fds[e]){const s=new TextDecoder("utf-8").decode(n.slice(t,t+r));return i.fds[e].path_create_directory(s)}},path_filestat_get(t,r,n,s,o){const f=new DataView(i.inst.exports.memory.buffer),d=new Uint8Array(i.inst.exports.memory.buffer);if(null!=i.fds[t]){const e=new TextDecoder("utf-8").decode(d.slice(n,n+s)),{ret:a,filestat:l}=i.fds[t].path_filestat_get(r,e);return null!=l&&l.write_bytes(f,o),a}return e.ERRNO_BADF},path_filestat_set_times(t,r,n,s,o,f,d){const a=new Uint8Array(i.inst.exports.memory.buffer);if(null!=i.fds[t]){const e=new TextDecoder("utf-8").decode(a.slice(n,n+s));return i.fds[t].path_filestat_set_times(r,e,o,f,d)}return e.ERRNO_BADF},path_link(t,r,n,s,o,f,d){const a=new Uint8Array(i.inst.exports.memory.buffer);if(null!=i.fds[t]&&null!=i.fds[o]){const e=new TextDecoder("utf-8").decode(a.slice(n,n+s)),l=new TextDecoder("utf-8").decode(a.slice(f,f+d));return i.fds[o].path_link(t,r,e,l)}return e.ERRNO_BADF},path_open(r,n,s,o,f,d,a,l,u){const _=new DataView(i.inst.exports.memory.buffer),c=new Uint8Array(i.inst.exports.memory.buffer);if(null!=i.fds[r]){const e=new TextDecoder("utf-8").decode(c.slice(s,s+o));t.debug.log(e);const{ret:p,fd_obj:w}=i.fds[r].path_open(n,e,f,d,a,l);if(0!=p)return p;i.fds.push(w);const y=i.fds.length-1;return _.setUint32(u,y,!0),0}return e.ERRNO_BADF},path_readlink(r,n,s,o,f,d){const a=new DataView(i.inst.exports.memory.buffer),l=new Uint8Array(i.inst.exports.memory.buffer);if(null!=i.fds[r]){const u=new TextDecoder("utf-8").decode(l.slice(n,n+s));t.debug.log(u);const{ret:_,data:c}=i.fds[r].path_readlink(u);if(null!=c){const t=(new TextEncoder).encode(c);if(t.length>f)return a.setUint32(d,0,!0),e.ERRNO_BADF;l.set(t,o),a.setUint32(d,t.length,!0)}return _}return e.ERRNO_BADF},path_remove_directory(t,r,n){const s=new Uint8Array(i.inst.exports.memory.buffer);if(null!=i.fds[t]){const e=new TextDecoder("utf-8").decode(s.slice(r,r+n));return i.fds[t].path_remove_directory(e)}return e.ERRNO_BADF},path_rename(e,t,r,n,s,o){throw"FIXME what is the best abstraction for this?"},path_symlink(t,r,n,s,o){const f=new Uint8Array(i.inst.exports.memory.buffer);if(null!=i.fds[n]){const e=new TextDecoder("utf-8").decode(f.slice(t,t+r)),d=new TextDecoder("utf-8").decode(f.slice(s,s+o));return i.fds[n].path_symlink(e,d)}return e.ERRNO_BADF},path_unlink_file(t,r,n){const s=new Uint8Array(i.inst.exports.memory.buffer);if(null!=i.fds[t]){const e=new TextDecoder("utf-8").decode(s.slice(r,r+n));return i.fds[t].path_unlink_file(e)}return e.ERRNO_BADF},poll_oneoff(e,t,r){throw"async io not supported"},proc_exit(e){throw new s(e)},proc_raise(e){throw"raised signal "+e},sched_yield(){},random_get(e,t){const r=new Uint8Array(i.inst.exports.memory.buffer);for(let n=0;n<t;n++)r[e+n]=256*Math.random()|0},sock_recv(e,t,r){throw"sockets not supported"},sock_send(e,t,r){throw"sockets not supported"},sock_shutdown(e,t){throw"sockets not supported"},sock_accept(e,t){throw"sockets not supported"}}}}})(),n})()));